<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='stylesheet' href='css/common.css'>
  </head>
  <body>
    <header></header>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {DropShadowNode} from './js/render/nodes/drop-shadow.js';
      import {vec3} from './js/render/math/gl-matrix.js';
      import {Ray} from './js/render/math/ray.js';

      // XR globals.
      let xrButton, xrRefSpace = null, xrViewerSpace = null, xrHitTestSource = null;

      // WebGL scene globals.
      let gl = null, renderer = null, scene = new Scene();
      scene.enableStats(false);

      let arObject = new Node();
      arObject.visible = false;
      arObject.addNode(new Gltf2Node({url: 'media/gltf/monkey.glb'}));
      scene.addNode(arObject);

      let reticle = new Gltf2Node({url: 'media/gltf/reticle.gltf'});
      reticle.visible = false;
      scene.addNode(reticle);

      // Ensure the background is transparent for AR.
      scene.clear = false;

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND"
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr)
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {xrButton.enabled = supported;});
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test']}).then((session) => {
          xrButton.setSession(session);
          onSessionStarted(session);
        });
      }

      function onSessionStarted(session) {
        session.addEventListener('select', onSelect);

        if (!gl) {
          gl = createWebGLContext({xrCompatible: true});
          renderer = new Renderer(gl);
          scene.setRenderer(renderer);
        }

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        // casting a ray from viewer to real world to set the reticle's source
        session.requestReferenceSpace('viewer').then((refSpace) => {
          xrViewerSpace = refSpace;
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            xrHitTestSource = hitTestSource;
          });
        });

        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onSelect(event) {
        if (reticle.visible) {
          arObject.visible = true;
          arObject.matrix = reticle.matrix;
          console.log(arObject);
        }
      }

      // Called every time a XRSession requests that a new frame be drawn.
      function onXRFrame(t, frame) {
        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);

        // If we have a hit test source, get its results for the frame
        // and use the pose to display a reticle in the scene.
        if (xrHitTestSource && pose) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (hitTestResults.length > 0 && !arObject.visible) {
            let pose = hitTestResults[0].getPose(xrRefSpace);
            reticle.visible = true;
            reticle.matrix = pose.transform.matrix;
          }
          // stops reticle from reappearing
          else if (arObject.visible) reticle.visible = false;
        }

        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, pose);
        scene.endFrame();
      }

      initXR();
    </script>
  </body>
</html>